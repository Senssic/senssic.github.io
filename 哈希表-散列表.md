---
title: 哈希表_散列表
date: 2018-08-20 21:30:31
tags: [数据结构,哈希表]
categories: [数据结构]
---



# 哈希表介绍

哈希表(也称散列表,hash table),是根据键值直接访问其对应的数据存储位置的一种数据结构。若使用数组或者链表来存储元素则在比较某个元素时,数组或链表需要循环进行比较,而通过哈希表只需要计算出对应的哈希位置取出对应的值进行比较或判断在否。

其有以下几种特性:

- 若关键字为k,则其值存放在f(k)*[散列函数]*的存储位置上。
- 对不同的关键字可能得到同一散列地址，即k1≠k2而f(k1)=f(k2),这种现象称为冲突。
- 若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为*均匀散列函数,*以便减少冲突。

## 构造哈希函数的方法

一个好的哈希函数能够提升查找效率减少哈希地址冲突带来的额外处理开销,常用的哈希函数有以下几种:

- 直接地址

  H(key) = key 或 H(key) = a*key + b，其中a和b为常数

- 平方取中法

  先计算出关键字值的平方，然后取平方值中间几位作为散列地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取中间的两位数{72，89，00}作为Hash地址。

- 折叠法

  将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将address(key)=89+03+24+12+3作为Hash地址。

- 除留取余法

  如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，address(key)=key%p。在这里p的选取非常关键，p选择的好的话，能够最大程度地减少冲突，p一般取不大于m的最大质数。当关键字是整数时候比较好的避免冲突。


- 数字分析法

  假设关键字是以*r*为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。

- 随机数法

  选择一个随机函数，把关键字的随机函数值作为它的哈希值,通常当关键字的长度不等时用这种方法。当关键字是小数的时候比较好的避免地址冲突。

## 解决哈希冲突

基于哈希的数据结构有着接近常量的时间即0(1)[*基于数据*]的时间复杂度,对于大量数据的查询效率极为高效。哈希的查找效率因数基本和*哈希函数是否均匀,处理冲突的方法,哈希表的加载因子*有关。

1. 开放地址法

   当发生冲突时,从当前位置向后按某种策略遍历哈希表。当发现可用的空间的时候,则插入元素。开放地址有一次探测(hs=(h(key)+i) ％ m,0 ≤ i ≤ m-1)、二次探测(hi=(h(key)+i\*i) ％ m，0 ≤ i ≤ m-1)和双重哈希(hs=(h(key)+i*h1(key)) ％ m,0 ≤ i ≤ m-1)。

   - 一次探测

     探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]，此后又循环到 T[0]，T[1]，…，直到探查到 **有空余地址** 或者到 T[d-1]为止。

   - 二次探测

     探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1^2]，T[d+2^2]，T[d+3^2],…，等，直到探查到 **有空余地址** 或者到 T[d-1]为止。缺点是无法探查到整个散列空间。

   - 双重哈希

     探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+h1(d)], T[d + 2*h1(d)]，…，等。该方法使用了两个散列函数 h(key) 和 h1(key)，故也称为双散列函数探查法。定义 h1(key) 的方法较多，但无论采用什么方法定义，都必须使 h1(key) 的值和 m 互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。该方法是开放定址法中最好的方法之一。

   开放定址在解决当前冲突的情况下同时可能会导致新的冲突，而开链不会有这种问题。

2. 链地址法(又开链法)

   开链的思想是哈希表中的每个元素都是一个类似链表或者其他数据结构的 head。当出现冲突时，我们就在链表后面添加元素。这也就意味着，如果某一个位置冲突过多的话，插入的时间复杂段将退化为 O(N)。

   ![链地址法1](哈希表-散列表_4.jpeg)

   开链相比于开放定址局部性较差，在程序运行过程中可能引起操作系统的缺页中断，从而导致系统颠簸。

   ​

3. 再哈希法

   Hi=RH1（key） i=1，2，…，k

   当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。很多语言或者工具包再哈希的内部实现是使用了两个数组，其中一个作为备用。如果当前哈希表的负载因子（元素个数/哈希表容量大小）过大或者过小时，就将数据切换到备用数组里。

4. 建立一个公共溢出区

   假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]为溢出表用以存储发生冲突的记录。，凡是和基本表发生冲突的元素，一律填入溢出表。



## C语言实现哈希表

### 基于数组实现

```c
/* 
 * 题目：给定一个全部由字符串组成的字典，字符串全部由大写字母构成。其中为每个字符串编写密码，编写的 
 *       方式是对于 n 位字符串，给定一个 n 位数，大写字母与数字的对应方式按照电话键盘的方式： 
 *         2: A,B,C     5: J,K,L    8: T,U,V 
 *         3: D,E,F     6: M,N,O    9: W,X,Y,Z 
 *         4: G,H,I     7: P,Q,R,S 
 * 题目给出一个1--12位的数，找出在字典中出现且密码是这个数的所有字符串。字典中字符串的个数不超过5000。 
 *         
 * 思路：1.回溯法找出所有可能的字符串 
 *       2.在字典中查找此字符串是否存在。（字典存储采用哈希表存储）  
 * 
 */  
  
#include<stdio.h>  
#include<stdlib.h>  
#include<string.h>  
  
#define HASHTABLE_LENGTH 5001  //哈希表长度  
#define STRING_LENGTH   13     //单词最大长度  
  
//字符串  
typedef struct  
{  
    char str[STRING_LENGTH];  
    int length;  
}HString;  
  
HString string={'\0',0};             //暂存可能的字符串  
HString hashTable[HASHTABLE_LENGTH]; //哈希表  
  
//hash函数,构造哈希表  
void createHashTable(char *str)  
{  
    int i,key,step=1;  
    i=key=0;  
    while(str[i]){  
        key+=str[i++]-'A';  
    }  
    key%=HASHTABLE_LENGTH;  
    while(1){  
        if(hashTable[key].length==0){  
            hashTable[key].length=strlen(str);  
            strcpy(hashTable[key].str,str);  
            break;  
        }  
        key=(key+step+HASHTABLE_LENGTH)%HASHTABLE_LENGTH;  
        //处理冲突，线性探测再散列  
        if(step>0)  
            step=-step;  
        else{  
            step=-step;  
            step++;  
        }  
    }  
}  
  
//从文件中读字典  
void readString()  
{  
    int i;  
    char str[STRING_LENGTH];  
    char ch;  
    FILE *fp;  
    if((fp=fopen("document/dictionary.txt","r"))==NULL){     
       printf("can not open file!\n");     
       exit(0);     
    }    
      
    i=0;  
    while((ch=getc(fp))!=EOF){     
        if(ch=='\n'){//读完一个字符串  
            str[i]='\0';  
            createHashTable(str);  
            i=0;  
            continue;  
        }  
        str[i++]=ch;  
    }  
  
    if(fclose(fp)){     
        printf("can not close file!\n");     
        exit(0);     
    }     
}  
  
//在哈希表中查找是否存在该字符串,存在返回1，不存在返回0  
int search(char *str)  
{  
    int i,key,step=1;  
    i=key=0;  
    while(str[i]){  
        key+=str[i++]-'A';  
    }  
    key%=HASHTABLE_LENGTH;  
    while(1){  
        if(hashTable[key].length==0)  
            return 0;  
        if(strcmp(hashTable[key].str,str)==0){  
            return 1;  
        }  
        key=(key+step+HASHTABLE_LENGTH)%HASHTABLE_LENGTH;  
        //处理冲突，线性探测再散列  
        if(step>0)  
            step=-step;  
        else{  
            step=-step;  
            step++;  
        }  
    }  
    return 0;  
}  
  
//求所有可能的字符串  
void getString(char* num)  
{  
    int i,digit,max;  
    if(*num==0){//递归出口，字符串已到末尾  
        string.str[string.length]='\0';  
        if(search(string.str))//这个字符串存在于字典中，输出  
            puts(string.str);  
        return;  
    }  
  
    digit=*num-'0';//取第一位字符，转成数字  
    if(digit>=2&&digit<=6){  
        i=(digit-2)*3+'A';  
        max=(digit-2)*3+'A'+3;  
    }  
    else if(digit==7){  
        i='P';  
        max='P'+4;  
    }  
    else if(digit==8){  
        i='T';  
        max='T'+3;  
    }  
    else if(digit==9){  
        i='W';  
        max='W'+4;  
    }  
  
    for(i;i<max;i++){  
        string.str[string.length++]=i;  
        getString(num+1); //递归  
        string.length--;  
    }  
}  
  
void main()  
{  
    char num[STRING_LENGTH];   //由于输入的数字超出了unsigned long的范围，所以用字符串来存储  
    readString();              //把字典从文件中读入内存  
    printf("please inputer an number(1--12位,不能有0或1)\n");  
    scanf("%s",num);  
    getString(num);  
}  
```



### 基于链表实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/*=================hash table start=========================================*/

#define HASH_TABLE_MAX_SIZE 10000
typedef struct HashNode_Struct HashNode;

struct HashNode_Struct
{
    char* sKey;
    int nValue;
    HashNode* pNext;
};

HashNode* hashTable[HASH_TABLE_MAX_SIZE]; //hash table data strcutrue
int hash_table_size;  //the number of key-value pairs in the hash table!

//initialize hash table
void hash_table_init()
{
    hash_table_size = 0;
    memset(hashTable, 0, sizeof(HashNode*) * HASH_TABLE_MAX_SIZE);
}


//string hash function
unsigned int hash_table_hash_str(const char* skey)
{
    const signed char *p = (const signed char*)skey;
    unsigned int h = *p;
    if(h)
    {
        for(p += 1; *p != '\0'; ++p)
            h = (h << 5) - h + *p;
    }
    return h;
}

//insert key-value into hash table
void hash_table_insert(const char* skey, int nvalue)
{
    if(hash_table_size >= HASH_TABLE_MAX_SIZE)
    {
        printf("out of hash table memory!\n");
        return;
    }

    unsigned int pos = hash_table_hash_str(skey) % HASH_TABLE_MAX_SIZE;

    HashNode* pHead =  hashTable[pos];
    while(pHead)
    {
        if(strcmp(pHead->sKey, skey) == 0)
        {
            printf("%s already exists!\n", skey);
            return ;
        }
        pHead = pHead->pNext;
    }

    HashNode* pNewNode = (HashNode*)malloc(sizeof(HashNode));
    memset(pNewNode, 0, sizeof(HashNode));
    pNewNode->sKey = (char*)malloc(sizeof(char) * (strlen(skey) + 1));
    strcpy(pNewNode->sKey, skey);
    pNewNode->nValue = nvalue;

    pNewNode->pNext = hashTable[pos];
    hashTable[pos] = pNewNode;


    hash_table_size++;
}
//remove key-value frome the hash table
void hash_table_remove(const char* skey)
{
    unsigned int pos = hash_table_hash_str(skey) % HASH_TABLE_MAX_SIZE;
    if(hashTable[pos])
    {
        HashNode* pHead = hashTable[pos];
        HashNode* pLast = NULL;
        HashNode* pRemove = NULL;
        while(pHead)
        {
            if(strcmp(skey, pHead->sKey) == 0)
            {
                pRemove = pHead;
                break;
            }
            pLast = pHead;
            pHead = pHead->pNext;
        }
        if(pRemove)
        {
            if(pLast)
                pLast->pNext = pRemove->pNext;
            else
                hashTable[pos] = NULL;

            free(pRemove->sKey);
            free(pRemove);
        }
    }
}

//lookup a key in the hash table
HashNode* hash_table_lookup(const char* skey)
{
    unsigned int pos = hash_table_hash_str(skey) % HASH_TABLE_MAX_SIZE;
    if(hashTable[pos])
    {
        HashNode* pHead = hashTable[pos];
        while(pHead)
        {
            if(strcmp(skey, pHead->sKey) == 0)
                return pHead;
            pHead = pHead->pNext;
        }
    }
    return NULL;
}

//print the content in the hash table
void hash_table_print()
{
    printf("===========content of hash table=================\n");
    int i;
    for(i = 0; i < HASH_TABLE_MAX_SIZE; ++i)
        if(hashTable[i])
        {
            HashNode* pHead = hashTable[i];
            printf("%d=>", i);
            while(pHead)
            {
                printf("%s:%d  ", pHead->sKey, pHead->nValue);
                pHead = pHead->pNext;
            }
            printf("\n");
        }
}

//free the memory of the hash table
void hash_table_release()
{
    int i;
    for(i = 0; i < HASH_TABLE_MAX_SIZE; ++i)
    {
        if(hashTable[i])
        {
            HashNode* pHead = hashTable[i];
            while(pHead)
            {
                HashNode* pTemp = pHead;
                pHead = pHead->pNext;
                if(pTemp)
                {
                    free(pTemp->sKey);
                    free(pTemp);
                }

            }
        }
    }
}

/* ===============================hash table end=========================*/


/* ============================test function ============================*/
#define MAX_STR_LEN 20
#define MIN_STR_LEN 10
void rand_str(char r[])
{
    int i;
    int len = MIN_STR_LEN + rand() % (MAX_STR_LEN - MIN_STR_LEN);
    for(i = 0; i < len - 1; ++i)
        r[i] = 'a' + rand() % ( 'z' - 'a');
    r[len - 1] = '\0';
}

int main(int argc, char** argv)
{
    srand(time(NULL));
    hash_table_init();
    printf("insert testing.........\n");
    int n = 10;
    const char *key1 = "aaammd";
    const char *key2 = "xzzyym";
    const char *key3 = "cdcded";

    hash_table_insert(key1, 110);
    hash_table_insert(key2, 220);
    hash_table_insert(key3, 330);
    char str[MAX_STR_LEN + 1];
    while(n--)
    {
        rand_str(str);
        hash_table_insert(str, n);
    }
    hash_table_print();

    printf("\nlookup testing..........\n");
    HashNode* pNode = hash_table_lookup(key1);
    printf("lookup result:%d\n", pNode->nValue);
    pNode = hash_table_lookup(key2);
    printf("lookup result:%d\n", pNode->nValue);

    printf("\nremove testing..........\n");
    printf("before remove %s:\n", key3);
    hash_table_print();
    hash_table_remove(key3);
    printf("after remove:\n");
    hash_table_print();
    hash_table_release();

    system("pause");
    return 0;
}
```







---

[哈希表的实现(1)](http://www.cnblogs.com/xiekeli/archive/2012/01/13/2321207.html)

[一次性了解哈希相关概念：哈希 哈希函数 冲突解决 哈希表](https://juejin.im/entry/5810e02f2e958a0055219394)

[聊一聊哈希表](http://legendtkl.com/2017/07/23/about-hash-table/)

[哈希表详解（附实现代码）](https://www.jianshu.com/p/de33dc676a3f)

[散列表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)

---

