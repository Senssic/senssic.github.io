<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式锁的常见实现]]></title>
    <url>%2F2018%2F08%2F17%2Fsenssic.github.io%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[现在的系统部署大部分都是分布式部署的方式,对于需要使用锁的场景不能再通过使用单纯的Java Api实现。产生了基于数据库，缓存(redis,memcached,tair),和zookeeper实现的分布式锁。 对于分布式锁我们希望的理想锁的表现 在分布式环境中保证同一个临界区在同一时间只在一台机器上执行。 这把分布式锁是可重入锁[避免死锁] 可以根据业务需要变成阻塞锁 获取和释放锁性能高 基于数据库实现分布式锁基于唯一索引实现1.创建一张带唯一索引的表 12345678CREATE TABLE `blockLock` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `block_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的块名称', `desc` varchar(1024) NOT NULL DEFAULT '备注信息', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成', PRIMARY KEY (`id`), UNIQUE KEY `uidx_method_name` (`block_name `) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2.在想要添加锁的块代码之前插入数据,由于block_name做了唯一索引,同样块名称的操作只能有一个成功。 1insert into methodLock(method_name,desc) values (‘block_name’,‘the same block_name commit’); 3.临界代码执行完毕需要释放锁,此时只需要将block_name这条数据删除或更新即可 1delete from methodLock where method_name ='block_name' 优点: 实现方便,便于理解 缺点: 如果数据库是单点,则可靠性不能保证 没有失效时间,不会自动释放锁,一旦解锁失败会导致其他线程无法再获取到锁。 这把锁只能是非阻塞的,插入失败直接报错返回,无法自动阻塞再次尝试获取锁 这把锁是非重入锁,线程获取锁后无法再次获取此锁,因为数据库已存在唯一索引值。 对于基于数据库的锁获取和释放锁的开销相对比较大 基于数据库的排他锁在mySql的InnoDB引擎的查询语句后增加for update,这样在查询的过程中数据库会增加排他锁【注意:如果想使用查询参数要建立唯一索引,由于InnoDB 预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住】。 添加锁代码1234567891011121314151617181920public boolean lock()&#123; Long timeout=10000； long futureTime = System.currentTimeMillis() + timeOuts; connection.setAutoCommit(false) while(true)&#123; try&#123; result = select * from blockLock where block_name=xxx for update; if(result==null)&#123; return true; &#125; &#125;catch(Exception e)&#123; &#125; sleep(1000); if(futureTime&lt;System.currentTimeMillis())&#123; break; &#125; &#125; return false;&#125; 释放锁代码123public void unlock()&#123; connection.commit();&#125; 优点: 阻塞锁,for update语句会一直等待直到执行成功后返回结果 自动释放锁,当数据库连接断开时候会自动释放锁 缺点: 如果数据库是单点,则可靠性不能保证 对于基于数据库的锁获取和释放锁的开销相对比较大 使用不当容易变成表级锁,容易影响业务 利用事务进行加锁的时候会导致很多连接不能及时释放,导致连接池爆满 基于缓存实现分布式锁相较于数据库实现的分布式锁,基于缓存实现的分布式锁更加高效，且有很多成熟的方案,redis,memcached以及tair等都有很好的支持。 下面是基于redis实现的分布式锁 添加锁代码123456789101112private static final String LOCK_SUCCESS = "OK";private static final String SET_IF_NOT_EXIST = "NX";private static final String SET_WITH_EXPIRE_TIME = "PX";public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime); if (LOCK_SUCCESS.equals(result)) &#123; return true; &#125; return false;&#125; 第一个为key，我们使用key来当锁，因为key是唯一的。 第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。 第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作； 第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。 第五个为time，与第四个参数相呼应，代表key的过期时间。 ##释放锁代码: 12345678910111213private static final Long RELEASE_SUCCESS = 1L;public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) &#123; //就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。 String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) &#123; return true; &#125; return false; &#125; 首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。使用Lua语言来确保上述操作是原子性。 优点： 缓存服务可以做集群提高可用性 获取锁和释放锁效率高 可以设置超时时间,超时会自动释放锁 缺点: 这是把非阻塞锁,无论成功失败会直接返回 这是把非重入锁,当一个线程获取锁后在释放锁前此线程无法再次获得该锁 失效时间平衡设置比较困难(时间短,会产生并发问题,时间长,会导致浪费的资源等待) 基于zookeeper实现分布式锁zookeeper会为客户端加锁的请求建立唯一一个瞬时有序节点,判断获取锁只需要判断此节点是否为此有序节点中序号最小的一个。当释放锁时候,只需要将这个瞬时节点删除可以。 使用curator客户端操作zookeeper 123456789101112131415161718public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; try &#123; return interProcessMutex.acquire(timeout, unit); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return true;&#125;public boolean unlock() &#123; try &#123; interProcessMutex.release(); &#125; catch (Throwable e) &#123; log.error(e.getMessage(), e); &#125; finally &#123; executorService.schedule(new Cleaner(client, path), delayTimeForClean, TimeUnit.MILLISECONDS); &#125; return true;&#125; 优点: 锁释放,当客户获取锁后突然挂掉(session连接断开),临时节点会自动删除。其他客户端可以再次获取锁 可实现阻塞锁,客户端通过在zk中创建有顺序节点,并且绑定监听,如果节点变化zk会通知客户端,客户端检查自己创建的节点是不是当前所有节点中序号最小的从而判断是否获取到锁。 可重入,客户端在创建节点时,zk会把当前客户端主机信息和线程信息写到节点中,客户端线程再次想获取锁时候和当前最小节点的数据对比一下就可以了。如果信息一样便是已获取到锁。 高可用,zk是集群部署的。 缺点: 由于需要很多判断和信息写入读取,以及分发信息,效率并没有基于缓存的高 有极低的概率会(zk有重试机制只有多次重试仍检测不到客户端心跳就会删除客户端临时节点)导致并发问题,如:当网络抖动失去客户端连接,别的客户端可能会得到分布式锁。 分布式锁的几种实现Redis 分布式锁的正确实现方式（ Java 版 ）]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java锁相关]]></title>
    <url>%2F2018%2F08%2F16%2Fsenssic.github.io%2Fjava%E9%94%81%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[在并发系统中常常需要对某些业务资源进行加锁操作，解决一些因并发操作导致的数据不一致,以及读到脏数据问题。 加锁的目的本质上是对资源的一种操作控制,防止其数据或状态出现不可控的变化。 java中对于锁的支持使用volatilejava提供了volatile关键字,在多个处理器中可以立即读到最新的值,即一个线程修改值后另一个线程立即能获取到更新后的值。 在某些适用volatile场景的地方使用volatile控制线程变量可见性会起到很好的效果,虽然volatile不能代替synchronize(因为volatile不能提供原子操作,只是对于多线程的变量可见性),但在适用的场景下要优于synchronize执行成本,因为它不会引起线程上下文的切换和调度。 使用synchronizesynchronize通过锁机制实现同步具体锁对象有三种方式 普通方法的同步,锁是当前实力对象 静态方法的同步,锁是当前类的class对象 对于同步代码块,锁是括号内的对象 synchronize的实现原理synchronize是通过jvm执行Monitor的互斥执行和协作来实现锁的。 互斥:使用synchronize获取的对象锁来进行共享数据线程互斥 协作:通过notify/notifyAll/wait方法同步线程之间的操作 必要条件:每个Object和Class都关联了一个monitor Monitor 的工作机理 线程进入同步方法中。 为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）,对于重入的synchronize关键字monitor会讲进入数自增1,所以synchronize是可重入锁 拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。 其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。 同步方法执行完毕了，线程退出临界区，并释放监视锁。 synchronize锁机制的优化为了减少锁获取和释放带来的开销在JSE1.6版本锁的状态达到了四个,级别从低到高依次为 无锁状态&lt;偏向锁状态&lt;轻量级锁状态&lt;重量级锁状态随着竞争激烈程度依次递增。synchronize不支持锁的降级,这种策略是为了提高获取和释放锁的效率。 偏向锁-一段代码一直被同一个线程访问,那么该线程自动获取锁,此举为了降低获取锁的代价。 优点:加锁和解锁不需要额外的消耗,和非同步代码比较仅存在纳秒级别的差距。 缺点:一旦出现锁竞争会有撤销锁的消耗。 轻量级锁-当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。 优点:线程不阻塞,提高性能 缺点:如果长时间得不到锁自旋会消耗cpu 重量级锁-当锁是轻量级锁的时候,另一个线程虽然在自旋但不会一直自旋,当自旋到一定次数还没有获取到锁就会进入阻塞该锁膨胀为重量级锁,重量级锁会让其他申请的线程进入阻塞,性能降低。 优点:不会消耗cpu 缺点:线程阻塞,响应时间缓慢。 自旋状态-轻量级锁的具体实现原理,指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 CAS(compare and swap)和AQS(AbstractQueuedSynchronizer)CAS的介绍CAS是一个原子操作,利用了处理器的CMPXCHG指令实现的,CAS操作包括三个操作数,内存位置(V),预期原值(A)和新值(B)。如果内存位置和预期原值相等则处理器会将内存位置更新为新值(B),若反之则不做任何操作。 CAS的优点在于竞争不大的情况下系统开销小,缺点是只能保证一个变量的原子操作,以及不能避免ABA问题(如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A,当前线程的CAS操作无法分辨当前V值是否发生过变化)。 AQS的介绍AQS是JDK下提供的一套用于实现基于FIFO等待队列的阻塞锁或相关的同步组件的一个同步框架。 AQS的实现原理内部通过一个volatile的int类型成功变量表示同步状态 123456789101112131415161718192021222324252627282930/** * The synchronization state. * 同步状态 */private volatile int state;/** * Returns the current value of synchronization state. * 获取当前同步状态 */protected final int getState() &#123; return state;&#125;/** * Sets the value of synchronization state. * 设置当前同步状态 */protected final void setState(int newState) &#123; state = newState;&#125;/** * Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * 使用CAS设置当前状态,该方法能保证状态设置的原子性 */protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 内置的FIFO双向队列来完成获取锁线程的排队工作 同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。 未获取到锁的线程将创建一个节点，设置到尾节点 首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点 独占式和共享式获取锁独享锁-指该锁一次只能被一个线程所持有共享锁-指该锁可被多个线程所持有 独占锁(ReentrantLock) ​ 每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁 ​ 独占式锁获取流程 ​ 共享锁(CountDownLatch) ​ 共享式与独占式的区别 ​ 共享锁获取流程 Java中的锁 (原理、锁优化、CAS、AQS)Java中的锁分类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好,世界]]></title>
    <url>%2F2018%2F08%2F09%2Fsenssic.github.io%2F%E4%BD%A0%E5%A5%BD%2C%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[你好,世界 你好,世界！不要在生活中迷失！ –2018年08月07日01:38:41]]></content>
      <categories>
        <category>生活百味</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>杂项</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
